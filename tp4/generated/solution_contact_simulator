hq    = []   ### For storing the logs of measured trajectory q
hqdes = []   ### For storing the logs of desired trajectory qdes

for i in range(10000):
    t = i * dt

    # Compute the model.
    M = pin.crba(robot.model, robot.data, q)
    b = pin.nle(robot.model, robot.data, q, vq)

    # Compute the PD control.
    tauq = -Kp * (q - qdes(t)) - Kv * (vq - qdes.velocity(t)) + qdes.acceleration(t)

    # Simulated the resulting acceleration (free aacceleration)
    aq0 = inv(M) @ (tauq - b)

    # Compute collision
    colwrap.computeCollisions(q, vq)

    # Get collision data
    collisions = colwrap.getCollisionList()

    if not collisions:
        in_col = {}
        aq = aq0
    else:
        dist = colwrap.getCollisionDistances(collisions)
        J = colwrap.getCollisionJacobian(collisions)
        JdotQdot = colwrap.getCollisionJdotQdot()

        vq -= pinv(J) @ J @ vq

        # Compute constraint accelation following gauss principle
        A = M
        b = M @ aq0
        C = J.T
        d = - (JdotQdot.squeeze() + Kp_c * dist + Kv_c * (J @ vq))

        [aq, cost, _, niter, lag, iact] = quadprog.solve_qp(A,b,C,d)

    # Integrate the acceleration.
    vq += aq * dt
    q = pin.integrate(robot.model, q, vq * dt)

    # Display every TDISP iterations.
    TDISP = 50e-3    # Display every 50ms
    if not i % int(TDISP / dt):  # Only display once in a while ...
        viz.display(q)
        time.sleep(TDISP)

    # Log the history.
    hq.append(q.copy())
    hqdes.append(qdes.copy())